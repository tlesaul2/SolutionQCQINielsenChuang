%!TeX root=../solnQCQI.tex

\chapter{Introduction to computer science}
\Textbf{3.1} \textbf{(Non-computable processes in Nature)} How might we recognize that a process in Nature computes a function non computable by a Turing machine?
\Soln There are several well known non-Turing-computable functions which if identified to be computable by a process in nature would provide examples.  For instance, the Halting problem: \url{https://en.wikipedia.org/wiki/Halting_problem}.   More specifically, since Turing machines map non-negative integers to non-negative integers, their input and output spaces are countable (\url{https://en.wikipedia.org/wiki/Countable_set}).  If any process in nature was found to compute a function taking input or providing output from an uncountable space, this could not be computed using a Turing machine.  Note, Turing machines could compute the function within any desired level of approximation, but could not compute the function exactly.

\Textbf{3.2} \textbf{(Turing numbers)}  Show that single-tape Turing machines can each be given a number from a list 1,2,3,\ldots in such a way that the number uniquely specifies the corresponding machine.  We call this number the \textit{Turing number} of the corresponding machine.  (\textit{Hint}:  Every positiive integer has a unique prime factorizatization $p_1^{a_1}p_2^{a_2}\ldots p_k^{a_k}$, where $p_i$ are distinct prime numbers and $a_1,\ldots, a_k$ are non-negative integers.)
\Soln Per the hint, we show that a Turing machine can be encoded uniquely be a finite ordered list of integer values $[a_1, a_2, \ldots, a_k]$.  Unique prime factorization can be used to encode the Turing machine as the non-negative integer $\prod_i p_i^{a_i}$, where $p_i$ is the $i$-th prime, starting with $p_1 = 2, p_2 = 3,\ldots$. A non-negative integer corresponding to a Turing machine can then be decoded to reproduce the unique Turing machine whose encoding gives rise to it via the exponents in it's unique prime factorization. What follows is likely overly detailed for some.  The basic idea is that each part of the the Turing machine can be encoded in a finite sequence of non-negative integers and decoded from that sequence.  Concatenating those sequences (carefully) is then enough to specify the Turing machine.  Note, it will not be the case that all non-negative integers correspond to valid Turing machines, but this is not required.  We'll extend this encoding to encode Turing machines in operation, and explain how operation of a Turing machine can be simulated by multiplication of it's Turing number by a rational number determined conditionally by the Turing number itself.  [Note: it is unclear how useful this extension will be. The idea is relatively simple, but its formal specification is intricate and very much not necessary to understand.  Feel free to skip it.] 

To produce an encoding of a Turing machine, we encode each of it's elements separately.  We start with the finite state control.  The finite state control consists of a finite set of $m+2$ states $Q = \{q_s, q_1, \ldots, q_m, q_h\}$.  Individually, it doesn't matter what form the $q_i$ take, only that they are distinguishable.  The integers $0, 1,\ldots, m, m+1$ are distinguishable, so all that is required to encode a finite state machine is a single integer.  So, setting $a_1=m$  allows $a_1$ to track the size of the finite state machine and is enough to encode it.

To encode the tape, we let $a_2$ be the size of the alpthabet $\Gamma$: $a_2 = |\Gamma|$, where here $\Gamma$  includes the starting character $\triangleright$, corresponding to tape value 0, and blank character $b$ corresponding to tape value $a_2-1$.  The other states may be assumed to be non-negative integers $1, \ldots, a_2-2$.  To encode the entirety of the tape, note that only a finite number of squares are non-blank.  Let $\beta$ be the largest index of a non-blank tape square.  Then set $a_3 = \beta$, and for each tape square with index $i$, for $1\leq i\leq \beta$, set $a_{3+i}$ equal to the non-negative integer value assigned to the alphabet character occupying tape square $i$.  All tape squares with index more than $\beta$ are blank and need not be encoded.   Note that by construction $a_4=0$ for all Turing machines, since tape square 1 always contains $\triangleright$, which was assigned value 0.  

Next, we encode the program.    The program contains a finite ordered list of program lines, say $\pi$ of them.  Set $a_{3+\beta+1} = \pi$.  For $1\leq i \leq \pi$, we encode program line $i$ with a second prime factorization. Program line $i$ consists of 5 elements: $\braket{q_i, x_i, q_i', x_i', s_i}$.  Here, $q_i$ and $q_i'$ are states in $Q$ which can be indexed with non-negative integers, say $\ell_{i,1}$ and $\ell_{i,3}$, with $0\leq \ell_{i,1},\ell_{i,3}\leq m+1$.  $x_i$ and $x_i'$ are characters in the alphabet $\Gamma$ which can be indexed with non-negative integers, say $\ell_{i,2}$ and $\ell_{i,4}$, with $0\leq \ell_{i,2}, \ell_{i,4} < |\Gamma| (= a_2)$.  $s_i$ is an integer value that is either -1, 0, or 1.  Setting $\ell_{i,5} = s_i$ directly leaves open the possibility that $\ell_{i,5} = -1$, which in turn will yield non-integer encodings of the program line.  There are several ways to circumvent this, the likely easiest of which is to set $\ell_{i,5} = s_i+1$. However, the author prefers setting $\ell_{i,5} = s_i~\%~3$, the remainder of $s_i$ when divided by 3 (its residue modulo 3).   This allows $s_i=0$ and $s_i=1$ to be encoded as $\ell_{i,5}=0$ and $\ell_{i,5}=1$, which are natural Boolean indicators that the tape-head should advance to the right, but requires $s_i=-1$ be encoded as $\ell_{i,5}=2$, indicating that the tape-head should move to the left.  Now, to encode program line $i$, for $1\leq i\leq \pi$, set $a_{3+\beta+1+i} = 2^{\ell_{i,1}}\cdot3^{\ell_{i,2}}\cdot5^{\ell_{i,3}}\cdot7^{\ell_{i,4}}\cdot11^{\ell_{i,5}}$.  

Now, for a Turing machine $M$, assigning Turing number $\tau(M) = \prod\limits_{i=1}^{3+\beta+1+\pi} p_i^{a_i}$ produces an integer encoding.  To show that it is unique, we reverse the encoding process and argue that all pieces of the Turing machine can be recovered uniquely from this integer value.  Let an encoding of a Turing machine, $\tau(M)$, be given and begin with its unique prime factorization $\tau(M) = \prod\limits_{i=1}^{\omega(\tau(M))} p_i^{a_i}$, where here $\omega$ is a function that returns the largest index of a prime that divides input integer.  [Note, $a_4=0$ will mean that this isn't the number of distinct prime factors].  Immediately, we recover the size of the finite state machine, \textit{i.e.} $m$.  It contains $a_1$ states indexed by integers, along with the special starting and halting state $q_s$ and $q_h$.  Next, the size of the alphabet $\Gamma$ is given by $a_2$, where here $\Gamma$ includes the starting character $\triangleright$ and the blank character $b$.  Next, the encoding of the tape starts with $a_3=\beta$ which indicates the maximum index of a non-blank tape square.  $\beta$ encodings of tape squares follow, starting with $a_4=0$, indicating that tape square 1 contains the starting character $\triangleright$, which was assigned character value 0.  If $a_4\neq0$, the integer provided could not be an encoding of a Turing machine, violating the assumption that $\tau(M)$ was such an integer.  $a_{3+i}$ encodes the value stored on the tape at index $i$, for $i\leq i \leq \beta$, where $a_{3+i}=a_2-1$ indicates the tape square $i$ is blank.  All tape squares with index $i$, for $i > \beta$, are assumed to be blank.  It is left only to decode the program.  We start with its length $\pi = a_{3+\beta+1}$.  $\pi$ encodings of individual program lines should follow, each of which should be of the form $a_{3+\beta+1+i} = 2^{\ell_{i,1}}\cdot3^{\ell_{i,2}}\cdot5^{\ell_{i,3}}\cdot7^{\ell_{i,4}}\cdot11^{\ell_{i,5}}$, from which we can recover $q_i = \ell_{i,1}$, $x_i = \ell_{i,2}$, $q_i' = \ell_{i,3}$, $x_i'=\ell_{i,4}$, and $s_i=\ell_{i,5}~\widetilde{\%}~3$, where here $\widetilde{\%}~3$ is modular reduction on to the set of residues $-1,0$, and $1$, instead of the standard set of residues $0,1,2$.  Note that $r~\widetilde{\%}~3 = ((r+1)~ \% ~3) - 1$.  It is easy to see that the program line encoded by $a_{3+\beta_1+i}$ is uniquely determined, as is the initial state of the tape from $a_3,\ldots, a_{3+\beta}$.  The alphabet $\Gamma$ is uniquely determined by $a_2$, and the finite state machine is uniquely determined by its size, given by $a_1$.  So, the entirety of the Turing machine $M$ can be uniquely recovered from it's Turing number $\tau(M)$, so $\tau(M)$ is unique. 

\noindent \textbf{(Extension):} Note that, as defined, our encoding uniquely encodes Turing machines in their initial state $q_s$, with read-write tape-head positioned on tape square 1 holding the starting character $\triangleright$.  The encoding scheme could be extended to encode Turing machines in operation by adding an encoding of the current state in the finite state control and current position of the read-write tape-head which will require only two additional prime factors and exponents.  For compatibility, to encode the current state of the finite state machine, we use $a_{3+\beta+1+\pi+1}$, where $a_{3+\beta+1+\pi+1} = 0$ indicates the state machine is in starting state $q_s$, and $a_{3+\beta+1+\pi+1} = m+1$ indicates the state machine is in state $q_h$ and has halted.  To encode the position of the read-write tape-head we require one more additional prime factor and exponent. For compatibility, we use $a_{3+\beta+1+\pi+2}$.  Full compatibility of encoding will require $a_{3+\beta+1+\pi+2}=0$ to indicate that the machine is not yet operating and that the read-write tape-head has not yet been positioned on a tape square, neither tape square 1 holding $\triangleright$, as encoded by $a_4=0$, or another subsequent tape square holding any other value.  Having $a_{3+\beta+1+\pi+2}>0$ indicates that the Turing machine $M$ is in operation in state specified by $a_{3+\beta+1+\pi+1}$, which we'll call $\sigma$, and read-write tape-head on the tape square specified by $a_ {3+\beta+1+\pi+2}$, which we'll call $\sigma$.  Note then that the tape-square pointed to by the read-write tape-head would contain the value specified by $a_{3+a_ {\sigma}}$, which we'll call $\nu$.

Now, to simulate execution of the Turing machine, note that in each step the program list is searched for a pattern matching it's current state and the character in the tape square being read by the read-write tape-head, that is, for $\braket{\sigma,\nu,\cdot,\cdot,\cdot}$.  This is equivalent to searching $a_{4+\beta+1},\ldots,a_{4+\beta+\pi}$ for an integer divisible by $2^{\sigma}\cdot 3^{\nu}$, but no more powers of 2 or 3. Once a matching $a_{4+\beta+i}$ is found, the multiplicities of $5, 7$, and $11$ in its factorization will give values for $\ell_{i,3}, \ell_{i,4}$, and $\ell_{i,5}$. The finite state machine can then be updated by multiplying by $p_{3+\beta+1+\pi+1}^{\ell_{i,3}-\sigma}$.  The contents of the tape can be updated by multiplying by $p_{3+a_\sigma}^{\ell_{i,4}-\nu}$.  The read-write tape-head can be moved by multiplying by $p_{3+\beta+1+\pi+2}^{\ell_{i,5}~\widetilde{\%}~3 }$.  Doing so will change the Turing number of the machine in operation $M$ to the number encoding $M$ after a single step.

\Textbf{3.3} \textbf{(Turing machine to reverse a bit string)}  Describe a Turing machine which takes a binary number $x$ as input, and outputs the bits of x in reverse order. (\textit{Hint}: In this and the next exercise it may help to use a mutli-tape Turing machine and/or symbols other than $\triangleright$, 0, 1, and the blanks.)
\Soln By ``takes a binary number $x$ as input'', what is meant is the non-blank portion of the tape contains the value $x$, encoded somehow.  In general, the tap can hold more than just function input, but for this problem that won't be necessary.  We'll use a two-tape machine, with both tapes containing symbols from the alphabet $\triangleright, 0, 1, b$.  Tape 1 will contain $\triangleright$, followed by the input value $x$ in binary, followed by blanks indicated with $b$s.  The second tape will contain $\triangleright$ and blanks.  The Turing machine will populate the second tape with the reversed binary value of $x$, followed by blanks.  It will not clear the first tape (although that could be done without too much trouble).  Before we define the program, we specify that the finite state machine will contain 4 states, the starting state $q_s$, the halted state $q_h$, a search state $s$, and a write state $w$.  Now, consider the program
\begin{align*}
P=\left\{
\begin{array}{ccccccccrrr}     1: &\langle&q_s,&\triangleright,&\triangleright,&s,&\triangleright,&\triangleright,&+1,&0&\rangle\\
       2: &\langle&s,& 0,&\triangleright,&s,&0,&\triangleright,&+1,&0&\rangle \\
       3: &\langle&s,& 1,& \triangleright,& s,& 1,& \triangleright,& +1,&0&\rangle \\
       4: &\langle&s,& b,& \triangleright,& w,& b,& \triangleright,& -1,& +1&\rangle \\
       5: &\langle&w,& 0,& b,& w,& 0,& 0,& -1,& +1&\rangle \\
       6: &\langle&w,& 1,& b,& w,& 1,& 1,& -1,& +1&\rangle \\ 
       7: &\langle&w,& \triangleright,& b,& q_h,& \triangleright,& b,& 0,& 0&\rangle
       \end{array}\right.
\end{align*}
Execution of the Turing machine begins by executing line 1 of P, which moves tape-head 1 forward, leaves tape-head 2 in place, and sets the state of the finite state machine to the search state. While in the search state, the program operates by executing lines 2 and 3, advancing tape-head 1 leaving the content of tape 1 unchanged, until it reaches a blank indicating that the end of the input has been reached, finally matching line 4.  Once the blank on tape 1 is reached, line 4 changes the finite state machine to the write state, shifts tape-head 1 to the last bit of input, and advancing tape-head 2 to the first position in tape 2.  Until the start of tape 1 is encountered, the program operates by executing lines 5 and 6, each of which copies the character on tape 1 pointed to be tape-head 1 onto tape 2 in the position pointed to by tape-head 2.  It then moves the tape-heads in opposite directions so that tape-head 1 points to the preceeded bit of input and tape-head 2 points to the next bit of output.  When the start of tape 1 is encountered, line 7 explicitly halts the program.   Explicitly halting is not necessary in this case.  Note, tape 1 could be cleared by replacing $x_1'$ in lines 5 and 6 with $b$s.  Then, the output could be moved to tape 1 while simultaneously clearing tape 2 by replacing line 7 with:
\begin{align*}
\begin{array}{rccccccrrrr}     7: \langle&w,& \triangleright,& b,& w,& \triangleright,& b,& 0,& -1&\rangle \\
        8: \langle&w,& \triangleright,& 0,& w,& \triangleright,& 0,& 0,& -1&\rangle \\
        9: \langle&w,& \triangleright,& 1,& w,& \triangleright,& 1,& 0,& -1&\rangle \\
        10: \langle&w,& \triangleright,& \triangleright,& w,& \triangleright,& \triangleright,& +1,& +1&\rangle \\
        11: \langle&w,&  b,& 1,& w,& 1,& b,& +1,& +1&\rangle \\
        12: \langle&w,&  b,& 0,& w,& 0,& b,& +1,& +1&\rangle \\
        13: \langle&w,&  b,& b,& q_h,& b,& b,& 0,& 0&\rangle \\
\end{array}
\end{align*}
Here, line 7 reverses the direction of tape-head 2. Lines 8 and 9 allow it to retreat to the start of tape 2 in line 10, at which point tape-head 1 and 2 are advanced in tandem and the blank in tape 1 is swapped with the bit in tape 2, one bit at a time, by executing lines 11 and 12.  Once tape-head 2 is at the end of the reversed bit-string, line 13 is reached, explicitly halting the program.
        